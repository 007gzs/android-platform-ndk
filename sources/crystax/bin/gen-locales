#!/usr/bin/env ruby

# Copyright (c) 2011-2015 CrystaX .NET.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY CrystaX .NET ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CrystaX .NET OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of CrystaX .NET.

require 'optparse'
require 'open3'
require 'fileutils'
require 'digest'

options = {}
parser = OptionParser.new do |o|
    o.on("--host=HOST", "Specify FreeBSD host to retrieve locales from") do |h|
        options[:host] = h
    end

    o.on("-o", "--output=FILE", "Specify output file to save generated locales and it's initialization code") do |f|
        options[:out] = f
    end
end
parser.parse(ARGV)

if options[:out].nil?
    $stderr.puts parser
    exit 1
end

$licfile = File.join(File.dirname(__FILE__), '..', 'LICENSE')
abort "Can't find LICENSE file" unless File.exists?($licfile)

host_os, = Open3.capture3("uname -s")
if host_os.chomp.downcase != "freebsd" && options[:host].nil?
    $stderr.puts parser
    exit 1
end

if options[:host].nil?
    ROOTDIR = File.realpath("/usr/share/locale")
else
    puts "Checking remote host #{options[:host]} ..."
    rem_host_os, = Open3.capture3("ssh #{options[:host]} uname -s")
    if rem_host_os.chomp.downcase != "freebsd"
        $stderr.puts "Remote host #{options[:host]} is not FreeBSD host"
        exit 1
    end

    FileUtils.mkdir_p "/tmp/locale"
    ROOTDIR = File.realpath("/tmp/locale")
    FileUtils.rm_rf ROOTDIR
    FileUtils.mkdir_p ROOTDIR
    at_exit { FileUtils.rm_rf ROOTDIR }

    puts "Retrieving locale data from #{options[:host]} ..."
    _, re, rs = Open3.capture3("rsync -aq --delete #{options[:host]}:/usr/share/locale/ #{ROOTDIR}/")
    if !rs.success?
        $stderr.puts "Couldn't copy locales from #{options[:host]}:"
        $stderr.write re
        exit 1
    end
end

def add_license(f)
    File.open($licfile, "r") do |l|
        f.puts "/*"
        while line = l.gets
            f.puts " * #{line}".rstrip
        end
        f.puts " */"
    end
end

locales = []

Dir.glob(File.join(ROOTDIR, "**/*")).each do |e|
    next if File.directory?(e)

    le = e.sub("#{ROOTDIR}/", '')
    abort "Wrong locale file found: #{e}" if le.split('/').size != 2
    locale = {encoding: le.split('/')[0], type: le.split('/')[1]}

    puts "Generating locale #{le} ..."

    if File.symlink?(e)
        sl = File.realpath(e).sub("#{ROOTDIR}/", '')
        abort "Wrong symlink found: #{le} -> #{sl}" if sl.split('/').size != 2
        abort "Alias point to another locale type: #{le} -> #{sl}" if locale[:type] != sl.split('/')[1]
        locale[:alias] = sl.split('/')[0]
    else
        bo, be, bs = Open3.capture3("bzip2 -9 -c #{e}")
        abort "Can't compress #{e}:\n#{be}" unless bs.success?
        locale[:compressed] = bo.size < File.size?(e)
        locale[:data] = locale[:compressed] ? bo : File.read(e)
    end

    locales << locale
end

def blobname(locale)
    "__crystax_locale_blob_#{Digest::SHA256.new.update(locale[:encoding]).update("-").update(locale[:type]).hexdigest}"
end

puts "Generating initialization code ..."
FileUtils.mkdir_p File.dirname(options[:out])
File.open(options[:out], "w") do |f|
    f.puts "/* THIS IS AUTOGENERATED FILE. DO NOT MODIFY IT MANUALLY!!! */"
    f.puts "/* GENERATED BY: #{$0} #{ARGV.select { |x| x !~ /^--host=/ }.join(' ')} */"
    f.puts ""
    add_license(f)
    f.puts ""
    f.puts "#include <pthread.h>"
    f.puts "#include <crystax/ctassert.h>"
    f.puts "#include <crystax/localeimpl.h>"
    f.puts ""
    locales.each do |ll|
        next unless ll[:alias].nil?
        bname = blobname(ll)
        f.puts "/* #{"BZip2 compressed " if ll[:compressed]}#{ll[:encoding]} #{ll[:type]} locale data */"
        f.puts "static uint8_t  #{bname}[] = {"
        idx = 0
        linesize = 16
        ll[:data].each_byte do |byte|
            f << "\n" if idx > 0 && idx % linesize == 0
            f << "    " if idx % linesize == 0
            f << "0x%02X" % byte
            idx += 1
            f << (idx == ll[:data].bytesize ? "\n" : ",")
        end
        f.puts "};"
        f.puts "__CRYSTAX_STATIC_ASSERT(sizeof(#{bname}) == #{ll[:data].bytesize}, \"Wrong size of locale's blob\");"
        f.puts ""
    end
    f.puts "static __crystax_locale_data_t __crystax_locale_data_array[#{locales.map { |x| x[:encoding] }.sort.uniq.size}];"
    f.puts ""
    f.puts "size_t __crystax_locale_table_size()"
    f.puts "{"
    f.puts "    return sizeof(__crystax_locale_data_array)/sizeof(__crystax_locale_data_array[0]);"
    f.puts "}"
    f.puts ""
    f.puts "__crystax_locale_data_t * __crystax_locale_data(size_t idx)"
    f.puts "{"
    f.puts "    if (idx >= __crystax_locale_table_size())"
    f.puts "        return NULL;"
    f.puts "    return &__crystax_locale_data_array[idx];"
    f.puts "}"
    f.puts ""
    f.puts "static void __crystax_locale_init_impl()"
    f.puts "{"
    f.puts "    memset(&__crystax_locale_data_array, 0, sizeof(__crystax_locale_data_array));"
    idx = 0
    locales.map { |x| x[:encoding] }.sort.uniq.each do |enc|
        f.puts ""
        f.puts "    __crystax_locale_data_array[#{idx}].encoding = \"#{enc}\";"
        locales.select { |x| x[:encoding] == enc }.each do |ll|
            bname = blobname(ll)
            if ll[:alias].nil?
                f.puts "    __crystax_locale_data_array[#{idx}].data[#{ll[:type]}].alias = NULL;"
                f.puts "    __crystax_locale_data_array[#{idx}].data[#{ll[:type]}].blob.data = #{bname};"
                f.puts "    __crystax_locale_data_array[#{idx}].data[#{ll[:type]}].blob.size = sizeof(#{bname});"
                f.puts "    __crystax_locale_data_array[#{idx}].data[#{ll[:type]}].blob.compressed = #{ll[:compressed] ? 1 : 0};"
            else
                f.puts "    __crystax_locale_data_array[#{idx}].data[#{ll[:type]}].alias = \"#{ll[:alias]}\";"
            end
        end
        idx += 1
    end
    f.puts "}"
    f.puts ""
    f.puts "static int volatile __crystax_locale_init_flag = 0;"
    f.puts "static pthread_mutex_t __crystax_locale_init_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;"
    f.puts ""
    f.puts "int __crystax_locale_init()"
    f.puts "{"
    f.puts "    int rc;"
    f.puts "    if (__sync_add_and_fetch(&__crystax_locale_init_flag, 0) == 0)"
    f.puts "    {"
    f.puts "        if ((rc = pthread_mutex_lock(&__crystax_locale_init_mutex)) != 0) return rc;"
    f.puts "        if (__crystax_locale_init_flag == 0)"
    f.puts "        {"
    f.puts "            __crystax_locale_init_impl();"
    f.puts "            __crystax_locale_init_flag = 1;"
    f.puts "        }"
    f.puts "        if ((rc = pthread_mutex_unlock(&__crystax_locale_init_mutex)) != 0) return rc;"
    f.puts "    }"
    f.puts "    return 0;"
    f.puts "}"
end

puts "DONE"
