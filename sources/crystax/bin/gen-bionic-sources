#!/usr/bin/env ruby

# Copyright (c) 2011-2015 CrystaX.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY CrystaX ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CrystaX OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of CrystaX.

require 'fileutils'
require 'pathname'
require 'digest'

MYNAME = Pathname.new(File.expand_path(__FILE__)).relative_path_from(Pathname.new(File.expand_path('../..', __FILE__))).to_s

TOPDIR = File.realpath(File.join(File.dirname(__FILE__), '..'))
SRCDIR = File.realpath(File.join(TOPDIR, '..', '..', '..', 'bionic'))

PRIVATEDIR = File.join(TOPDIR, 'gen', 'bionic')
PUBLICDIR  = File.join(TOPDIR, 'include')

ARCHS = [
    "arm",
    "x86",
    "mips",
    "arm64",
    "x86_64",
    "mips64",
]

class Generator
    def initialize
        @files = []
        @fixups = {}
    end

    def license
        @license = File.read(File.join(TOPDIR, 'LICENSE')).split("\n").map(&:chomp) if @license.nil?
        @license
    end
    private :license

    def relpath(path, from)
        Pathname.new(path).relative_path_from(Pathname.new(from)).to_s
    end
    private :relpath

    def fixup(name, &block)
        raise "Fixup '#{name}' already added" if @fixups.has_key?(name.to_s)
        raise "No code block given" unless block_given?
        @fixups[name.to_s] = lambda { |f| block.call(f) }
    end

    def add(f, options = {})
        raise "No such file: #{f}" unless File.exists?(File.join(SRCDIR, f))
        raise "File #{f} already added" if @files.include?(f)
        @files << {file: f, options: options}
    end

    def generate
        total = @files.size
        current = 0
        @files.each do |e|
            f = e[:file]
            options = e[:options]

            src = File.join(SRCDIR, f)
            mdst = File.join(options[:public] ? File.join(PUBLICDIR, 'crystax', 'bionic') : PRIVATEDIR, File.dirname(f), "mangled-#{File.basename(f)}")

            if options[:public]
                f = f.split('/')[2..-1].join('/') if f.split('/')[0..1] == %w{libc include}
                f = f.split('/')[3..-1].join('/') if f.split('/')[0..3] == %w{libc kernel uapi linux}
                dst = File.join(PUBLICDIR, f)
            else
                dst = File.join(PRIVATEDIR, f)
            end

            next if File.exists?(dst) && File.exists?(mdst) &&
                File.mtime(dst)  >= File.mtime(mdst) &&
                File.mtime(mdst) >= File.mtime(src) &&
                File.mtime(dst)  >= File.mtime(__FILE__) &&
                File.mtime(mdst) >= File.mtime(__FILE__)

            current += 1
            puts "GEN  [#{current}/#{total}] #{f}"

            FileUtils.rm_f mdst
            FileUtils.mkdir_p File.dirname(mdst)
            FileUtils.cp src, mdst

            FileUtils.mkdir_p File.dirname(dst)
            File.open(dst, "w") do |df|
                df.puts "/* WARNING!!! THIS IS AUTO-GENERATED FILE!!! DO NOT MODIFY IT MANUALLY!!! */"
                df.puts "/* GENERATED BY: $CRYSTAX/#{MYNAME} */"
                df.puts ""

                df.puts "/*"
                license.each do |line|
                    df.puts " * #{line}".rstrip
                end
                df.puts " */"

                guard = "__CRYSTAX_INCLUDE_#{Digest::SHA256.new.update(relpath(dst, TOPDIR)).hexdigest}".upcase
                df.puts ""
                df.puts "#ifndef #{guard}"
                df.puts "#define #{guard}"

                fixups = options[:fixup]
                fixups = [] if fixups.nil?
                fixups = [fixups] unless fixups.is_a?(Array)
                df.puts "" unless fixups.empty?
                fixups.each do |fxname|
                    fx = @fixups[fxname.to_s]
                    raise "No such fixup: '#{fxname}'" if fx.nil?
                    fx.call(df)
                end

                df.puts ""
                if options[:public]
                    df.puts "#include <crystax/id.h>"
                    df.puts "#include <#{relpath(mdst, File.join(TOPDIR, 'include'))}>"
                else
                    df.puts "#include \"#{File.basename(mdst)}\""
                end

                df.puts ""
                df.puts "#endif /* #{guard} */"
            end
        end
    end
end

g = Generator.new

g.fixup :redefine_fcntl do |f|
    f.puts "#define fcntl __fcntl64"
end

# public headers
g.add "libc/include/machine/timespec.h",   public: true
g.add "libc/include/netinet/in.h",         public: true
g.add "libc/include/pwd.h",                public: true
g.add "libc/include/sched.h",              public: true
g.add "libc/include/sys/auxv.h",           public: true
g.add "libc/include/sys/glibc-syscalls.h", public: true
g.add "libc/include/sys/syscall.h",        public: true
g.add "libc/include/sys/sysconf.h",        public: true
g.add "libc/include/sys/sysinfo.h",        public: true
g.add "libc/include/sys/timerfd.h",        public: true
g.add "libc/kernel/uapi/linux/sched.h",    public: true

# common headers
g.add "libc/include/machine/posix_limits.h"
g.add "libc/private/ErrnoRestorer.h"
g.add "libc/private/ScopedReaddir.h"
g.add "libc/private/ThreadLocalBuffer.h"
g.add "libc/private/bionic_asm.h"
g.add "libc/private/bionic_macros.h"
g.add "libc/private/libc_events.h"
g.add "libc/private/libc_logging.h"

# include/machine/asm.h
g.add "libc/arch-arm/include/machine/asm.h"
g.add "libc/arch-arm64/include/machine/asm.h"
g.add "libc/arch-mips/include/machine/asm.h"
g.add "libc/arch-mips64/include/machine/asm.h"
g.add "libc/arch-x86/include/machine/asm.h"
g.add "libc/arch-x86_64/include/machine/asm.h"

# clock_getcpuclockid
g.add "libc/bionic/clock_getcpuclockid.cpp"

# clock_getres
g.add "libc/arch-arm/syscalls/clock_getres.S"
g.add "libc/arch-arm64/syscalls/clock_getres.S"
g.add "libc/arch-mips/syscalls/clock_getres.S"
g.add "libc/arch-mips64/syscalls/clock_getres.S"
g.add "libc/arch-x86/syscalls/clock_getres.S"
g.add "libc/arch-x86_64/syscalls/clock_getres.S"

# clock_nanosleep
g.add "libc/arch-arm/syscalls/___clock_nanosleep.S"
g.add "libc/arch-arm64/syscalls/___clock_nanosleep.S"
g.add "libc/arch-mips/syscalls/___clock_nanosleep.S"
g.add "libc/arch-mips64/syscalls/___clock_nanosleep.S"
g.add "libc/arch-x86/syscalls/___clock_nanosleep.S"
g.add "libc/arch-x86_64/syscalls/___clock_nanosleep.S"
g.add "libc/bionic/clock_nanosleep.cpp"

# eventfd
g.add "libc/arch-arm/syscalls/eventfd.S"
g.add "libc/arch-arm64/syscalls/eventfd.S"
g.add "libc/arch-mips/syscalls/eventfd.S"
g.add "libc/arch-mips64/syscalls/eventfd.S"
g.add "libc/arch-x86/syscalls/eventfd.S"
g.add "libc/arch-x86_64/syscalls/eventfd.S"
g.add "libc/bionic/eventfd_read.cpp"
g.add "libc/bionic/eventfd_write.cpp"

# fadvise
g.add "libc/arch-arm/syscalls/__arm_fadvise64_64.S"
g.add "libc/arch-arm64/syscalls/__fadvise64.S"
g.add "libc/arch-mips/syscalls/__fadvise64.S"
g.add "libc/arch-mips64/syscalls/__fadvise64.S"
g.add "libc/arch-x86/syscalls/__fadvise64.S"
g.add "libc/arch-x86_64/syscalls/__fadvise64.S"

# fallocate/fallocate64
g.add "libc/arch-arm/syscalls/fallocate64.S"
g.add "libc/arch-arm64/syscalls/fallocate.S"
g.add "libc/arch-mips/syscalls/fallocate64.S"
g.add "libc/arch-mips64/syscalls/fallocate.S"
g.add "libc/arch-x86/syscalls/fallocate64.S"
g.add "libc/arch-x86_64/syscalls/fallocate.S"

# fcntl/__fcntl64
g.add "libc/arch-arm/syscalls/__fcntl64.S"
g.add "libc/arch-arm64/syscalls/fcntl.S",    fixup: "redefine_fcntl"
g.add "libc/arch-mips/syscalls/__fcntl64.S"
g.add "libc/arch-mips64/syscalls/fcntl.S",   fixup: "redefine_fcntl"
g.add "libc/arch-x86/syscalls/__fcntl64.S"
g.add "libc/arch-x86_64/syscalls/fcntl.S",   fixup: "redefine_fcntl"

# getpwnam/getpwuid
g.add "libc/bionic/stubs.cpp"

# mkfifo
g.add "libc/bionic/mkfifo.cpp"

# mknodat
g.add "libc/arch-arm/syscalls/mknodat.S"
g.add "libc/arch-arm64/syscalls/mknodat.S"
g.add "libc/arch-mips/syscalls/mknodat.S"
g.add "libc/arch-mips64/syscalls/mknodat.S"
g.add "libc/arch-x86/syscalls/mknodat.S"
g.add "libc/arch-x86_64/syscalls/mknodat.S"

# mlockall
g.add "libc/arch-arm/syscalls/mlockall.S"
g.add "libc/arch-arm64/syscalls/mlockall.S"
g.add "libc/arch-mips/syscalls/mlockall.S"
g.add "libc/arch-mips64/syscalls/mlockall.S"
g.add "libc/arch-x86/syscalls/mlockall.S"
g.add "libc/arch-x86_64/syscalls/mlockall.S"

# munlockall
g.add "libc/arch-arm/syscalls/munlockall.S"
g.add "libc/arch-arm64/syscalls/munlockall.S"
g.add "libc/arch-mips/syscalls/munlockall.S"
g.add "libc/arch-mips64/syscalls/munlockall.S"
g.add "libc/arch-x86/syscalls/munlockall.S"
g.add "libc/arch-x86_64/syscalls/munlockall.S"

# pipe2
g.add "libc/arch-arm/syscalls/pipe2.S"
g.add "libc/arch-arm64/syscalls/pipe2.S"
g.add "libc/arch-mips/syscalls/pipe2.S"
g.add "libc/arch-mips64/syscalls/pipe2.S"
g.add "libc/arch-x86/syscalls/pipe2.S"
g.add "libc/arch-x86_64/syscalls/pipe2.S"

# posix_madvise
g.add "libc/bionic/posix_madvise.cpp"

# sched_getaffinity
g.add "libc/arch-arm/syscalls/__sched_getaffinity.S"
g.add "libc/arch-arm64/syscalls/__sched_getaffinity.S"
g.add "libc/arch-mips/syscalls/__sched_getaffinity.S"
g.add "libc/arch-mips64/syscalls/__sched_getaffinity.S"
g.add "libc/arch-x86/syscalls/__sched_getaffinity.S"
g.add "libc/arch-x86_64/syscalls/__sched_getaffinity.S"
g.add "libc/bionic/sched_getaffinity.cpp"

# sched_getcpu
g.add "libc/bionic/sched_getcpu.cpp"
g.add "libc/arch-arm/syscalls/__getcpu.S"
g.add "libc/arch-arm64/syscalls/__getcpu.S"
g.add "libc/arch-mips/syscalls/__getcpu.S"
g.add "libc/arch-mips64/syscalls/__getcpu.S"
g.add "libc/arch-x86/syscalls/__getcpu.S"
g.add "libc/arch-x86_64/syscalls/__getcpu.S"

# sched_cpualloc
g.add "libc/bionic/sched_cpualloc.c"

# sched_cpucount
g.add "libc/bionic/sched_cpucount.c"

# sched_setaffinity
g.add "libc/arch-arm/syscalls/sched_setaffinity.S"
g.add "libc/arch-arm64/syscalls/sched_setaffinity.S"
g.add "libc/arch-mips/syscalls/sched_setaffinity.S"
g.add "libc/arch-mips64/syscalls/sched_setaffinity.S"
g.add "libc/arch-x86/syscalls/sched_setaffinity.S"
g.add "libc/arch-x86_64/syscalls/sched_setaffinity.S"

# sysconf
g.add "libc/bionic/sysconf.cpp"
g.add "libc/bionic/sysinfo.cpp"

# termios
g.add "libc/bionic/termios.cpp"

# tgkill
g.add "libc/arch-arm/syscalls/tgkill.S"
g.add "libc/arch-arm64/syscalls/tgkill.S"
g.add "libc/arch-mips/syscalls/tgkill.S"
g.add "libc/arch-mips64/syscalls/tgkill.S"
g.add "libc/arch-x86/syscalls/tgkill.S"
g.add "libc/arch-x86_64/syscalls/tgkill.S"

# timerfd_create
g.add "libc/arch-arm/syscalls/timerfd_create.S"
g.add "libc/arch-arm64/syscalls/timerfd_create.S"
g.add "libc/arch-mips/syscalls/timerfd_create.S"
g.add "libc/arch-mips64/syscalls/timerfd_create.S"
g.add "libc/arch-x86/syscalls/timerfd_create.S"
g.add "libc/arch-x86_64/syscalls/timerfd_create.S"

# timerfd_gettime
g.add "libc/arch-arm/syscalls/timerfd_gettime.S"
g.add "libc/arch-arm64/syscalls/timerfd_gettime.S"
g.add "libc/arch-mips/syscalls/timerfd_gettime.S"
g.add "libc/arch-mips64/syscalls/timerfd_gettime.S"
g.add "libc/arch-x86/syscalls/timerfd_gettime.S"
g.add "libc/arch-x86_64/syscalls/timerfd_gettime.S"

# timerfd_settime
g.add "libc/arch-arm/syscalls/timerfd_settime.S"
g.add "libc/arch-arm64/syscalls/timerfd_settime.S"
g.add "libc/arch-mips/syscalls/timerfd_settime.S"
g.add "libc/arch-mips64/syscalls/timerfd_settime.S"
g.add "libc/arch-x86/syscalls/timerfd_settime.S"
g.add "libc/arch-x86_64/syscalls/timerfd_settime.S"

g.generate
