#!/bin/bash

# Copyright (c) 2011-2014 CrystaX .NET.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY CrystaX .NET ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CrystaX .NET OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of CrystaX .NET.

PROGDIR=`dirname $0`
PROGDIR=`cd $PROGDIR && pwd`

# Assume that we are under tests/
# and that the samples will be under samples/ and platforms/android-N/samples/
#
ROOTDIR=`cd $PROGDIR/.. && pwd`
NDK_BUILDTOOLS_PATH=$ROOTDIR/build/tools
. $NDK_BUILDTOOLS_PATH/ndk-common.sh
. $NDK_BUILDTOOLS_PATH/prebuilt-common.sh

PROGRAM_PARAMETERS=""

PROGRAM_DESCRIPTION=\
"Test Boost libraries built for the CrystaX NDK.

This requires a temporary NDK installation containing
toolchain binaries for all target architectures.

By default, this will try with the current NDK directory, unless
you use the --ndk-dir=<path> option.
"

NDK_DIR=$ANDROID_NDK_ROOT
register_var_option "--ndk-dir=<path>" NDK_DIR "Specify NDK root path for the build"

TEST_DIR=$HOME/.crystax/boost
OPTION_TEST_DIR=
register_var_option "--test-dir=<path>" OPTION_TEST_DIR "Specify test directory [$TEST_DIR]"

ABIS="$PREBUILT_ABIS"
register_var_option "--abis=<list>" ABIS "Specify list of target ABIs"

ADB=adb
register_var_option "--adb=<path>" ADB "Specify which adb to use"

DEVICES_FROM=
register_var_option "--devices-from=<file>" DEVICES_FROM "If specified, use device identificators from that file instead of auto-detecting them with 'adb devices'"

LIBRARIES=all
register_var_option "--libraries=<list>" LIBRARIES "Explicit list of libraries to test"

DEVICE_PATH=/data/local/tmp/boost-$(uuidgen)
register_var_option "--device-path=<path>" DEVICE_PATH "Path on device where to push files"

ADBRUNNER_LOCK_DIRECTORY=$TEST_DIR/lock
register_var_option "--adbrunner-lock-directory=<path>" ADBRUNNER_LOCK_DIRECTORY "Directory where to place per-emulator lock files for adbrunner"

REPORTS_PATH=$TEST_DIR/reports
register_var_option "--reports=<path>" REPORTS_PATH "Path to store HTML reports"

ENABLE_PIE=yes
register_option "--pie" do_pie "Produce PIE-enabled binaries to test (default)"
do_pie () { ENABLE_PIE=yes; }
register_option "--no-pie" do_no_pie "Produce PIE-disabled binaries to test"
do_no_pie () { ENABLE_PIE=no; }

DO_FETCH=no
register_option "--fetch-sources" do_fetch_sources "Fetch&update Boost sources"
do_fetch_sources () { DO_FETCH=yes; }

DO_REGRESSION_TESTING=yes
register_option "--skip-regression" do_skip_regression "Skip regression testing"
do_skip_regression () { DO_REGRESSION_TESTING=no; }

PUBLISH_RESULTS=no
register_option "--publish-results" do_publish_results "Publish test results, uploading them to the public FTP"
do_publish_results () { PUBLISH_RESULTS=yes; }

TOOLCHAIN_VERSIONS=gcc-4.9,gcc-4.8,clang-3.5,clang-3.4
register_var_option "--toolchain-versions=<ver>" TOOLCHAIN_VERSIONS "Toolchain versions"

TAG="master"
register_var_option "--tag=<value>" TAG "Boost tag to test ('master' or 'develop')"

BOOST_GIT_URL=https://github.com/boostorg/boost
register_var_option "--boost-url=<url>" BOOST_GIT_URL "Use alternative git URL for Boost sources"

BOOST_BUILD_GIT_URL=https://github.com/boostorg/build.git
register_var_option "--boost-build-url=<url>" BOOST_BUILD_GIT_URL "Use alternative git URL for Boost.Build sources"

BOOST_REGRESSION_GIT_URL=https://github.com/boostorg/regression.git
register_var_option "--boost-regression-url=<url>" BOOST_REGRESSION_GIT_URL "Use alternative git URL for Boost.Regression sources"

STD_CXX=
register_var_option "--std=<standard>" STD_CXX "Use specified C++ standard to build tests"

ICU_VERSION=
register_var_option "--with-icu=<version>" ICU_VERSION "Test with ICU"

register_jobs_option

extract_parameters "$@"

LIBCRYSTAX=$NDK_DIR/$CRYSTAX_SUBDIR

#ICU_VERSION=$(ls -1 $NDK_DIR/$ICU_SUBDIR/ 2>/dev/null | head -n 1)
if [ -n "$ICU_VERSION" ]; then
    ICU=$NDK_DIR/$ICU_SUBDIR/$ICU_VERSION
else
    ICU=""
fi

ABIS=$(commas_to_spaces $ABIS)
TOOLCHAIN_VERSIONS=$(commas_to_spaces $TOOLCHAIN_VERSIONS)

case $TAG in
    master|develop)
        ;;
    *)
        panic "Wrong tag value: '$TAG'"
esac

if [ -n "$OPTION_TEST_DIR" ]; then
    eval TEST_DIR=$OPTION_TEST_DIR
fi
mkdir -p "$TEST_DIR"
fail_panic "Cannot create test directory: $TEST_DIR"

REGRESSION_DIR="$TEST_DIR/$TAG/regression"
REPORT_DIR="$TEST_DIR/$TAG/report"

setup_default_log_file $TEST_DIR/test.log

mkdir -p $REPORTS_PATH
fail_panic "Cannot create results directory: $REPORTS_PATH"

STDBUF=
which stdbuf >/dev/null 2>&1 && STDBUF="stdbuf -o0"

f_at_exit=/tmp/atexit.$(uuidgen)
rm -f $f_at_exit

at_exit()
{
    echo "$@" >>$f_at_exit
}

cleanup()
{
    local pid
    cat $f_at_exit 2>/dev/null | {
        while read cmd; do
            echo "## CLEANUP: $cmd"
            $cmd
        done
    }
}

trap "cleanup" EXIT QUIT ABRT TERM
trap "printf '\\n\\n*** INTERRUPTED: $0\\n\\n'; exit 1" INT

WLOG=/tmp/wrappers-$(uuidgen).log
rm -f $WLOG
tail -F $WLOG | catlog &
WPID=$(jobs -p)

kill_wlog()
{
    kill -INT  $WPID 2>/dev/null
    sleep 0.5
    kill -KILL $WPID 2>/dev/null
}

at_exit kill_wlog

cleanup_devices()
{
    adb_devices | {
        while read D; do
            $ADB -s "$D" shell "rm -r $DEVICE_PATH 2>/dev/null"
        done
    }
}

at_exit cleanup_devices

mktool()
{
    local tool="$1"
    mkdir -p $(dirname $tool)
    fail_panic "Cannot create parent directory for tool $tool"
    cat >$tool
    fail_panic "Cannot create tool $tool"
    chmod +x $tool
    fail_panic "Cannot chmod +x $tool"
}

adb_getprop()
{
    local DEVID="$1"
    local PROPNAME="$2"
    $ADB -s "$DEVID" shell getprop $PROPNAME | tr -d '\r'
}

adb_devices()
{
    local ABI=$1
    local D C CPU_ABI CPU_ABI2 CPU_ABIS
    local APILEVEL

    if [ -n "$DEVICES_FROM" ]; then
        cat $DEVICES_FROM 2>/dev/null
        return
    fi

    $ADB devices | tr -d '\r' | sed -e '1d' | grep '\<device$' | sed -e 's/^\([^\t]*\).*$/\1/' | {
    while read D; do
        if [ -z "$ABI" ]; then
            echo "$D"
            continue
        fi

        APILEVEL=$(adb_getprop "$D" ro.build.version.sdk)
        if [ "$ENABLE_PIE" = "yes" ]; then
            if [ $APILEVEL -le 15 ]; then
                #echo "SKIP test on $D: android-$APILEVEL don't support PIE-enabled binaries"
                continue
            fi
        else
            if [ $APILEVEL -ge 21 ]; then
                #echo "SKIP test on $D: android-$APILEVEL don't support non-PIE binaries"
                continue
            fi
        fi

        CPU_ABIS=$(adb_getprop "$D" ro.product.cpu.abilist)
        if [ -z "$CPU_ABIS" ]; then
            CPU_ABI=$(adb_getprop "$D" ro.product.cpu.abi)
            CPU_ABI2=$(adb_getprop "$D" ro.product.cpu.abi2)
            CPU_ABIS="$CPU_ABI,$CPU_ABI2"
        fi
        CPU_ABIS=$(echo $CPU_ABIS | tr ',' ' ')
        if echo $CPU_ABIS | tr ' ' '\n' | grep -q -x armeabi-v7a; then
            CPU_ABIS="$CPU_ABIS armeabi-v7a-hard"
        fi
        DEVICE_ABI=$(echo $CPU_ABIS | tr ' ' '\n' | head -n 1)
        for C in $CPU_ABIS; do
            if [ "$C" != "$ABI" ]; then
                continue
            fi

            # Special case: Dell Venue x86 tablet specify 'ro.product.cpu.abi=x86' and 'ro.product.cpu.abi2=armeabi-v7a'.
            # However, only non-PIE-enabled armeabi-v7a binaries supported, even though for x86 binaries usual
            # rules applied - i.e. PIE binaries works starting from android-16 and non-PIE binaries works only up to android-19.
            case $C in
                armeabi-v7a*)
                    if [ "$DEVICE_ABI" = "x86" -a "$ENABLE_PIE" = "yes" ]; then
                        continue
                    fi
                    ;;
            esac

            echo "$D"
        done
    done
    }
}

# $1: ABI
# $2: toolchain type (gcc or clang)
# $3: toolchain version
# $4: target directory
generate_toolchain()
{
    local ABI=$1
    local TOOLCHAIN_TYPE=$2
    local TOOLCHAIN_VERSION=$3
    local DIR=$4

    local APILEVEL=9
    if [ ${ABI%%64*} != ${ABI} ]; then
        APILEVEL=21
    fi

    local TCNAME
    case $ABI in
        armeabi*)
            TCNAME=arm-linux-androideabi
            ;;
        arm64*)
            TCNAME=aarch64-linux-android
            ;;
        mips)
            TCNAME=mipsel-linux-android
            ;;
        mips64)
            TCNAME=mips64el-linux-android
            ;;
        x86|x86_64)
            TCNAME=$ABI
            ;;
        *)
            echo "ERROR: Unknown ABI: $ABI" 1>&2
            exit 1
    esac

    local TCPREFIX
    case $ABI in
        x86)
            TCPREFIX=i686-linux-android
            ;;
        x86_64)
            TCPREFIX=x86_64-linux-android
            ;;
        *)
            TCPREFIX=$TCNAME
    esac

    local LLVMTRIPPLE
    case $ABI in
        armeabi)
            LLVMTRIPPLE=armv5te-none-linux-androideabi
            ;;
        armeabi-v7a*)
            LLVMTRIPPLE=armv7-none-linux-androideabi
            ;;
        arm64-v8a)
            LLVMTRIPPLE=aarch64-none-linux-android
            ;;
        x86)
            LLVMTRIPPLE=i686-none-linux-android
            ;;
        x86_64)
            LLVMTRIPPLE=x86_64-none-linux-android
            ;;
        mips)
            LLVMTRIPPLE=mipsel-none-linux-android
            ;;
        mips64)
            LLVMTRIPPLE=mips64el-none-linux-android
            ;;
        *)
            echo "ERROR: Unknown ABI: $ABI" 1>&2
            exit 1
    esac

    local ARCH
    case $ABI in
        armeabi*)
            ARCH=arm
            ;;
        arm64*)
            ARCH=arm64
            ;;
        *)
            ARCH=$ABI
    esac

    local FLAGS LFLAGS LLIBS
    case $ABI in
        armeabi)
            FLAGS="-march=armv5te -mtune=xscale -msoft-float"
            ;;
        armeabi-v7a)
            FLAGS="-march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=softfp"
            LFLAGS="-Wl,--fix-cortex-a8"
            ;;
        armeabi-v7a-hard)
            FLAGS="-march=armv7-a -mfpu=vfpv3-d16 -mhard-float"
            LFLAGS="-Wl,--fix-cortex-a8"
            LFLAGS="$LFLAGS -Wl,--no-warn-mismatch"
            ;;
        arm64-v8a)
            FLAGS=""
            ;;
        x86)
            FLAGS="-m32"
            ;;
        x86_64)
            FLAGS="-m64"
            ;;
        mips)
            FLAGS="-mabi=32 -mips32"
            ;;
        mips64)
            FLAGS="-mabi=64 -mips64r6"
            ;;
    esac

    local GCCTCPATH
    local CCS
    case $TOOLCHAIN_TYPE in
        gcc)
            GCCTCPATH=$NDK_DIR/toolchains/$TCNAME-$TOOLCHAIN_VERSION/prebuilt/$HOST_TAG
            CCS="gcc g++"
            GNULIBCXX_VERSION=$TOOLCHAIN_VERSION
            ;;
        clang)
            LLVMGCCVERSION=4.9
            GCCTCPATH=$NDK_DIR/toolchains/$TCNAME-$LLVMGCCVERSION/prebuilt/$HOST_TAG
            LLVMTCPATH=$NDK_DIR/toolchains/llvm-$TOOLCHAIN_VERSION/prebuilt/$HOST_TAG
            CCS="clang clang++"
            GNULIBCXX_VERSION=$LLVMGCCVERSION
            ;;
        *)
            echo "ERROR: Unknown toolchain type: $TOOLCHAIN_TYPE" 1>&2
            exit 1
    esac

    local SYSROOT=$NDK_DIR/platforms/android-$APILEVEL/arch-$ARCH
    local GNULIBCXX=$NDK_DIR/sources/cxx-stl/gnu-libstdc++/$GNULIBCXX_VERSION

    FLAGS="$FLAGS --sysroot=$SYSROOT"

    FLAGS="$FLAGS -fPIC"
    if [ "$ENABLE_PIE" = "yes" ]; then
        FLAGS="$FLAGS -fPIE"
        LFLAGS="$LFLAGS -pie"
    fi

    LLIBS="-lgnustl_shared"

    local TOOL
    for TOOL in $CCS; do
        {
            cat <<EOF
#!/bin/bash

if echo "\$@" | tr ' ' '\\n' | grep -q -x -e -c; then
    LINKER=no
else
    LINKER=yes
fi

# Remove any -m32/-m64 from input parameters
PARAMS=\`echo "\$@" | tr ' ' '\\n' | grep -v -x -e -m32 | grep -v -x -e -m64 | tr '\\n' ' '\`
if [ "x\$LINKER" = "xyes" ]; then
    NPARAMS=""
    for p in \$PARAMS; do
        case \$p in
            -lrt|-pthread|-lpthread)
                continue
                ;;
        esac

        NPARAMS="\$NPARAMS \$p"
    done
    PARAMS=\$NPARAMS
fi

FLAGS="$FLAGS"
if [ "x\$LINKER" = "xyes" ]; then
    FLAGS="\$FLAGS $LFLAGS"
    if [ "x$ICU" != "x" ]; then
        FLAGS="\$FLAGS -L$ICU/libs/$ABI"
    fi
    FLAGS="\$FLAGS -L$LIBCRYSTAX/libs/$ABI"
    FLAGS="\$FLAGS -L$GNULIBCXX/libs/$ABI"
else
    if [ "x$ICU" != "x" ]; then
        FLAGS="\$FLAGS -I$ICU/include"
    fi
    FLAGS="\$FLAGS -I$GNULIBCXX/include"
    FLAGS="\$FLAGS -I$GNULIBCXX/libs/$ABI/include"
    FLAGS="\$FLAGS -I$LIBCRYSTAX/include"
    FLAGS="\$FLAGS -Wno-long-long"
fi

PARAMS="\$FLAGS \$PARAMS"
if [ "x\$LINKER" = "xyes" ]; then
    PARAMS="\$PARAMS $LLIBS"
fi

run()
{
    echo "## COMMAND: \$@" >>$WLOG
    exec "\$@"
}
EOF

            case $TOOLCHAIN_TYPE in
                gcc)
                    echo "run $GCCTCPATH/bin/$TCPREFIX-$TOOL \$PARAMS"
                    ;;
                clang)
                    echo "run $LLVMTCPATH/bin/$TOOL \\"
                    echo "    -target $LLVMTRIPPLE \\"
                    echo "    -gcc-toolchain $GCCTCPATH \\"
                    echo "    \$PARAMS"
                    ;;
                *)
                    echo "echo 'WRONG TOOLCHAIN TYPE: $TOOLCHAIN_TYPE' 1>&2"
                    echo "exit 1"
            esac
        } | mktool $DIR/$TOOL-$TOOLCHAIN_VERSION
        fail_panic "Cannot create target tool $TOOL"
    done

    for TOOL in as ar; do
        {
            echo "#!/bin/bash"
            echo 'run()'
            echo '{'
            echo '    echo "## COMMAND: $@" >>'$WLOG
            echo '    exec "$@"'
            echo '}'
            case $TOOLCHAIN_TYPE in
                gcc)
                    echo "run $GCCTCPATH/bin/$TCPREFIX-$TOOL \"\$@\""
                    ;;
                clang)
                    echo "run $LLVMTCPATH/bin/llvm-$TOOL \"\$@\""
                    ;;
                *)
                    echo "echo 'WRONG TOOLCHAIN TYPE: $TOOLCHAIN_TYPE' 1>&2"
                    echo "exit 1"
            esac
        } | mktool $DIR/$TOOL
        fail_panic "Cannot create target tool $TOOL"
    done

    for TOOL in ranlib strip; do
        {
            echo "#!/bin/bash"
            echo 'run()'
            echo '{'
            echo '    echo "## COMMAND: $@" >>'$WLOG
            echo '    exec "$@"'
            echo '}'
            echo "run $GCCTCPATH/bin/$TCPREFIX-$TOOL \"\$@\""
        } | mktool $DIR/$TOOL
        fail_panic "Cannot create target tool $TOOL"
    done
}

# $1: output file
generate_flock()
{
    local OUT="$1"
    local SRC=/tmp/flock-$(uuidgen).c

    rm -f $SRC
    at_exit "rm -f $SRC"

    cat >$SRC <<EOF
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/file.h>

int main(int argc, char *argv[])
{
    int fd;
    char *p;

    if (argc != 2)
        return 1;

    fd = strtol(argv[1], &p, 10);
    if (fd == 0 && p == argv[1])
        return 1;

    if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
        return 1;

    if (flock(fd, LOCK_EX) == -1)
        return 1;

    return 0;
}
EOF
    fail_panic "Cannot create temporary flock source file"

    run mkdir -p $(dirname $OUT)
    fail_panic "Cannot create directory for flock"

    run cc -o $OUT $SRC
    fail_panic "Cannot create flock utility"
}

# $1: ABI
# $2: target directory
# $3: 'flock' utility
# $4: 'strip' utility
generate_adbrunner()
{
    local ABI="$1"
    local DIR="$2"
    local FLOCK="$3"
    local STRIP="$4"

    local LIBDIR="$DIR/lib"
    run rm -Rf $LIBDIR

    local RUNTAG="EXITCODE$(uuidgen | sed 's,-,,g')"

    local ADBRUNNER=$DIR/adbrunner
    {
        echo '#!/bin/bash'
        echo ''
        echo 'LOG='$WLOG
        echo ''
        echo 'MYCMD="$0 $@"'
        echo ''
        echo 'echo "## COMMAND: $MYCMD" >>$LOG'
        echo ''
        echo 'F="$1"'
        echo 'shift'
        echo 'ARGS="$@"'
        echo 'MYPID=$$'
        echo 'BF=$(basename $F)'
        echo 'ABI="'$ABI'"'
        echo 'DEVPATH="'$DEVICE_PATH/$ABI'"'
        echo 'DSTPATH=$DEVPATH/$(uuidgen)'
        echo 'ADB="'$ADB'"'
        echo 'LOCKDIR="'$ADBRUNNER_LOCK_DIRECTORY'"'
        echo 'FLOCK="'$FLOCK'"'
        echo 'STRIP="'$STRIP'"'
        echo 'STDBUF="'$STDBUF'"'
        echo 'LIBDIR="'$LIBDIR'"'
        echo 'RUNTAG="'$RUNTAG'"'
        echo 'ADBFAILED=/tmp/adbfailed.$(uuidgen)'
        echo ''
        echo 'LIBCRYSTAX="'$LIBCRYSTAX'"'
        echo 'GNULIBCXX="'$NDK_DIR'/sources/cxx-stl/gnu-libstdc++/4.9"'
        if [ -n "$ICU" ]; then
            echo 'ICU="'$ICU'"'
        fi
        echo ''
        echo 'EXTRAS=""'
        echo ''
        echo 'EXTRAS_DIRS=""'
        echo 'for DIR in $(echo $LD_LIBRARY_PATH $DYLD_LIBRARY_PATH | tr ":" " "); do'
        echo '    EXTRAS_DIRS="$DIR $EXTRAS_DIRS"'
        echo 'done'
        echo ''
        echo 'for DIR in $EXTRAS_DIRS; do'
        echo '    for LIB in $(find $DIR -name "lib*.so*" -print 2>/dev/null); do'
        echo '        EXTRAS="$EXTRAS $LIB"'
        echo '    done'
        echo 'done'
        echo ''
        echo 'log()'
        echo '{'
        echo '    echo "## ADBRUNNER.$MYPID [$ANDROID_SERIAL] $@" >>$LOG'
        echo '}'
        echo ''
        echo 'panic()'
        echo '{'
        echo '    echo "## ADBRUNNER.$MYPID [$ANDROID_SERIAL] $@"'
        echo '    log "$@"'
        echo '    exit 1'
        echo '}'
        echo ''
        echo 'fail_panic()'
        echo '{'
        echo '    if [ $? -ne 0 ]; then'
        echo '        panic "$@"'
        echo '    fi'
        echo '}'
        echo ''
        echo 'adb_shell()'
        echo '{'
        echo '    local CMD="$@"'
        echo '    local ADBCAP=$F.adbcap.$(uuidgen)'
        echo '    local RC'
        echo '    log "RUN: $CMD"'
        echo '    rm -f $ADBCAP'
        echo '    rm -f $ADBFAILED'
        echo '    $ADB shell "$CMD ; echo \"${RUNTAG}:\$?\"" 2>&1 \'
        echo '        | $STDBUF sed -e "s,[[:cntrl:]],,g" \'
        echo '        | $STDBUF tee $ADBCAP \'
        echo '        >>$LOG'
        echo '    sed -e "\$d" $ADBCAP'
        echo '    local LAST=$(tail -n 1 $ADBCAP 2>/dev/null)'
        echo '    echo "$LAST" | sed -e "s,${RUNTAG}:.*\$,,"'
        echo '    echo "$LAST" | grep -q "$RUNTAG"'
        echo '    if [ $? -eq 0 ]; then'
        echo '        RC=$(echo "$LAST" | sed "s,^.*${RUNTAG}:,,")'
        echo '        log "EXIT CODE: $RC"'
        echo '    else'
        echo '        log "ADB FAILED: $LAST"'
        echo '        touch $ADBFAILED >>$LOG 2>&1'
        echo '        RC=1'
        echo '    fi'
        echo '    rm -f $ADBCAP'
        echo '    return $RC'
        echo '}'
        echo ''
        echo 'adb_push()'
        echo '{'
        echo '    local SRC="$1"'
        echo '    local DST="$2"'
        echo '    local BSRC'
        echo ''
        echo '    if [ -d $SRC ]; then'
        echo '        BSRC=$(basename $SRC)'
        echo '        adb_shell "mkdir -p $DST/$BSRC"'
        echo '        if [ $? -ne 0 ]; then'
        echo '            $ADB shell "rm -r $DST" >/dev/null 2>&1'
        echo '            touch $ADBFAILED >>$LOG 2>&1'
        echo '            panic "PUSH FAILED: $SRC"'
        echo '        fi'
        echo '        DST=$DST/$BSRC'
        echo '    fi'
        echo ''
        echo '    local CMD="$ADB push $SRC $DST"'
        echo '    log "PUSH: $CMD"'
        echo '    $CMD >>$LOG 2>&1'
        echo '    if [ $? -ne 0 ]; then'
        echo '        $ADB shell "rm -r $DST" >/dev/null 2>&1'
        echo '        touch $ADBFAILED >>$LOG 2>&1'
        echo '        panic "PUSH FAILED: $SRC"'
        echo '    fi'
        echo '}'
        echo ''
        echo 'while true; do'
        echo '    {'
        if [ -n "$DEVICES_FROM" ]; then
            echo '        cat '$DEVICES_FROM' 2>/dev/null'
        else
            echo '        cat <<EOD'
            adb_devices $ABI
            echo 'EOD'
        fi
        echo '    } | {'
        echo '    while read D; do'
        echo '        mkdir -p $LOCKDIR >/dev/null 2>&1'
        echo '        ('
        echo '        export ANDROID_SERIAL="$D"'
        echo ''
        echo '        log "LOCKING"'
        echo ''
        echo '        exec 3>"$LOCKDIR/$D.lock"'
        echo '        $FLOCK 3'
        echo '        fail_panic "LOCK FAILED"'
        echo ''
        echo '        log "START: $F $ARGS"'
        echo ''
        echo '        adb_shell "mkdir -p $DEVPATH/lib && mkdir -p $DEVPATH/tmp && mkdir -p $DSTPATH"'
        echo '        fail_panic "CANNOT CREATE REQUIRED DIRECTORIES"'
        echo ''
        echo '        for LIB in \'
        echo '            $LIBCRYSTAX/libs/$ABI/libcrystax.so \'
        echo '            $GNULIBCXX/libs/$ABI/libgnustl_shared.so \'
        if [ -n "$ICU" ]; then
            echo '            $ICU/libs/$ABI/lib*.so \'
        fi
        echo '            ; do'
        echo ''
        echo '            BLIB=$(basename $LIB)'
        echo ''
        echo '            adb_shell "test -e $DEVPATH/lib/$BLIB"'
        echo '            if [ $? -eq 0 ]; then'
        echo '                continue'
        echo '            fi'
        echo ''
        echo '            if [ ! -e $LIBDIR/$BLIB ]; then'
        echo '                mkdir -p $LIBDIR'
        echo '                fail_panic "MKDIR FAILED: $LIBDIR"'
        echo '                cp -f $LIB $LIBDIR/'
        echo '                fail_panic "COPY FAILED: $LIB -> $LIBDIR/"'
        echo '                $STRIP --strip-unneeded $LIBDIR/$BLIB'
        echo '                fail_panic "STRIP FAILED: $LIBDIR/$BLIB"'
        echo '            fi'
        echo ''
        echo '            adb_push "$LIBDIR/$BLIB" "$DEVPATH/lib"'
        echo '        done'
        echo ''
        echo '        for E in $F $EXTRAS; do'
        echo '            BE=$(basename $E)'
        echo '            echo $BE | grep -q -x libcrystax.so && continue'
        echo '            echo $BE | grep -q -x libgnustl_shared.so && continue'
        if [ -n "$ICU" ]; then
            echo '            echo $BE | grep -q "^libicu.*" && continue'
        fi
        echo '            $STRIP --strip-unneeded $E >/dev/null 2>&1'
        echo '            adb_push "$E" "$DSTPATH/$BE" && adb_shell "chmod 0755 $DSTPATH/$BE"'
        echo '        done'
        echo ''
        echo '        NEWARGS=""'
        echo '        for E in $ARGS; do'
        echo '            if [ -e $E ]; then'
        echo '                BE=$(basename $E)'
        echo '                adb_push "$E" "$DSTPATH/$BE"'
        echo '                NEWARGS="$NEWARGS $DSTPATH/$BE"'
        echo '            else'
        echo '                NEWARGS="$NEWARGS $E"'
        echo '            fi'
        echo '        done'
        echo ''
        echo '        adb_shell "cd $DSTPATH && LD_LIBRARY_PATH=$DEVPATH/lib:$DSTPATH TMPDIR=$DEVPATH/tmp ./$BF $NEWARGS"'
        echo '        RC=$?'
        echo '        $ADB shell "rm -r $DSTPATH" >/dev/null 2>&1'
        echo '        if [ $RC -ne 0 ]; then'
        echo '            log "RUN FAILED [\$?=$RC]: $F"'
        echo '            exit $RC'
        echo '        fi'
        echo ''
        echo '        exit 0'
        echo ''
        echo '        )'
        echo '        RC=$?'
        echo '        test $RC -eq 0 || break'
        echo '    done'
        echo '    }'
        echo '    RC=$?'
        echo '    echo "## ADBRUNNER.$MYPID: EXITCODE: $RC" >>$LOG'
        echo '    if [ -f $ADBFAILED ]; then'
        echo '        echo "## ADBRUNNER.$MYPID: ADB FAILED" >>$LOG'
        echo '        rm -f $ADBFAILED'
        echo '        sleep 5'
        echo '        continue'
        echo '    fi'
        echo '    exit $RC'
        echo 'done'
        echo ''
        echo 'exit 0'
    } | mktool $ADBRUNNER

}

# $1: target directory
copy_boost()
{
    local DIR="$1"

    # WARNING! This is intentionally just 'rm', not 'rm -rf'.
    # This is needed to remove $DIR if it's symlink.
    # Thus, we try to remove it and ignore any errors.
    # In case it's symlink - it will be removed.
    # In case it's directory - nothing will happen.
    rm $DIR >/dev/null 2>&1

    run mkdir -p $DIR
    fail_panic "Cannot create target directory for Boost sources"

    run rsync -a "$BOOST_SRCDIR/" "$DIR/"
    fail_panic "Cannot copy Boost sources"
}

copy_boost_bb()
{
    local DIR="$1"

    run mkdir -p $DIR
    fail_panic "Cannot create target directory for Boost.Build sources"

    run rsync -a "$BOOST_BB_SRCDIR/" "$DIR/"
    fail_panic "Cannot copy Boost.Build sources"
}

copy_boost_rr()
{
    local DIR="$1"

    run mkdir -p $DIR
    fail_panic "Cannot create target directory for Boost.Regression sources"

    run rsync -a "$BOOST_RR_SRCDIR/" "$DIR/"
    fail_panic "Cannot copy Boost.Regression sources"
}

cleanup_pjl()
{
    local DIR="$1"

    which objdump >/dev/null 2>&1
    fail_panic "Cannot find objdump utility"

    local F
    for F in $(find $DIR/build/bin -type f -a -name process_jam_log -print); do
        objdump -f $F | grep -q "^architecture: *i386:x86-64\>" && continue
        run rm -f $F
    done
}

prepare_boost_tools()
{
    local DIR="$1"

    mkdir -p $DIR
    fail_panic "Cannot create boost sources directory"

    local RUNPY=$DIR/run.py

    run cp -f $BOOST_RR_SRCDIR/src/run.py $RUNPY
    fail_panic "Cannot retrieve run.py"

    chmod +x $RUNPY
    fail_panic "Cannot chmod +x run.py"

    local BOOST_BB="$DIR/boost_bb"
    copy_boost_bb "$BOOST_BB"

    local BOOST_RR="$DIR/boost_regression"
    copy_boost_rr "$BOOST_RR"

    local TOOLS="                  \
        collect_and_upload_logs.py \
        process_jam_log.py         \
        regression.py              \
        "

    local T
    for T in $TOOLS; do
        run cp -f "$BOOST_RR/src/$T" "$DIR/"
        fail_panic "Cannot copy $T to $DIR"
    done

    cleanup_pjl "$BOOST_RR"

    (
    cd $DIR || exit 1
    run $RUNPY --use-local --tag=$TAG --bjam-options="-j$NUM_JOBS" setup || exit 1
    )
    fail_panic "Cannot setup regression tools"
}

# $1: ABI
# $2: test directory
test_boost_for_abi ()
{
    local ABI="$1"
    local TESTDIR="$2"
    local SRCDIR="$TESTDIR/test"

    dump "Run regression testing [$ABI]"

    run mkdir -p $TESTDIR && run mkdir -p $SRCDIR
    fail_panic "Cannot create temporary directory for $ABI testing"

    local STRIP=""
    local TOOLSETS=""
    local TOOLSETS_PATH=""
    local TOOLSET
    local TOOLCHAIN_TYPE TOOLCHAIN_VERSION
    local CXXBIN
    local CXXBINS=""

    local CONFIGJAM="$TESTDIR/config.jam"
    run rm -f $CONFIGJAM

    for TOOLCHAIN_VERSION in $TOOLCHAIN_VERSIONS; do
        if [ ${TOOLCHAIN_VERSION#clang} != ${TOOLCHAIN_VERSION} ]; then
            TOOLCHAIN_TYPE=clang
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#clang-}
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#clang}
            CXXBIN=clang++-$TOOLCHAIN_VERSION
        else
            TOOLCHAIN_TYPE=gcc
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#gcc-}
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#gcc}
            CXXBIN=g++-$TOOLCHAIN_VERSION
        fi

        if [ "$TOOLCHAIN_TYPE" = "clang" -a "$ABI" = "armeabi" ]; then
            # clang toolchains don't support armeabi good
            continue
        fi

        if [ "$TOOLCHAIN_TYPE" = "gcc" -a "$TOOLCHAIN_VERSION" = "4.8" -a ${ABI%%64*} != ${ABI} ]; then
            # gcc-4.8 don't support 64-bit targets
            continue
        fi

        TOOLSET=${TOOLCHAIN_TYPE}-${TOOLCHAIN_VERSION}

        local TARGETBIN=$TESTDIR/${TOOLSET}
        run rm -Rf $TARGETBIN

        # Generate toolchain wrappers
        generate_toolchain "$ABI" "$TOOLCHAIN_TYPE" "$TOOLCHAIN_VERSION" "$TARGETBIN"

        if [ -z "$TOOLSETS" ]; then
            TOOLSETS=$TOOLSET
        else
            TOOLSETS="$TOOLSETS,$TOOLSET"
        fi

        if [ -z "$TOOLSETS_PATH" ]; then
            TOOLSETS_PATH=$TARGETBIN
        else
            TOOLSETS_PATH=$TOOLSETS_PATH:$TARGETBIN
        fi

        echo "using $TOOLCHAIN_TYPE : $TOOLCHAIN_VERSION : $TARGETBIN/$CXXBIN ;" >>$CONFIGJAM
        fail_panic "Cannot add $TOOLSET to user config"

        CXXBINS="$CXXBINS $TARGETBIN/$CXXBIN"

        if [ -z "$STRIP" -a -x $TARGETBIN/strip ]; then
            STRIP=$TARGETBIN/strip
        fi
    done

    if [ -z "$STRIP" ]; then
        panic "Cannot detect strip for $ABI"
    fi

    # Generate adbrunner tool
    generate_adbrunner "$ABI" "$TESTDIR" "$FLOCK" "$STRIP"

    # Copy Boost sources
    copy_boost "$SRCDIR/boost_root"

    # Prepare Boost tools (bjam, process_jam_log)
    prepare_boost_tools "$SRCDIR"

    local FLEVELS=/tmp/apilevels.$(uuidgen)
    local DEVICES=/tmp/devices.$(uuidgen)
    rm -f $FLEVELS $DEVICES
    adb_devices $ABI | {
        local D
        while read D; do
            log "RUNNER: D='$D'"
            local APILEVEL=$(adb_getprop "$D" ro.build.version.sdk)
            local VERSION=$(adb_getprop "$D" ro.build.version.release)
            local DEVICE=$(adb_getprop "$D" ro.product.device)

            log "RUNNER: APILEVEL: '$APILEVEL'"
            log "RUNNER: VERSION:  '$VERSION'"
            log "RUNNER: DEVICE:   '$DEVICE'"

            local MODEL
            case $DEVICE in
                generic*)
                    MODEL=emulator
                    ;;
                *)
                    MODEL=$(adb_getprop "$D" ro.product.model)
            esac

            log "RUNNER: MODEL: '$MODEL'"

            echo $APILEVEL >>$FLEVELS

            {
                printf '<tr>'
                for V in "$VERSION" "$APILEVEL" "$MODEL"; do
                    printf '<td style="border: solid 1px #ccc; padding: 0.5em;">%s</td>' "$V"
                done
                printf '</tr>\n'
            } | cat >>$DEVICES
        done
    }
    log "RUNNER: FLEVELS:"
    cat $FLEVELS | sed 's,^,RUNNER: FLEVELS: ,' | catlog
    APILEVELS=$(cat $FLEVELS | sort | uniq | tr '\n' ' ')
    rm -f $FLEVELS
    log "RUNNER: APILEVELS: '$APILEVELS'"

    local COMMENT="$SRCDIR/comment.html"
    generate_runner_comment "$COMMENT" "$ABI" "$DEVICES" "$CONFIGJAM" "$CXXBINS"
    rm -f $DEVICES

    local RUNNER="CrystaX.NET-apilevel-$(echo $APILEVELS | tr -s ' ' | tr ' ' ',')-$ABI"
    log "RUNNER: RUNNER: '$RUNNER'"

    local RUNPY="$SRCDIR/run.py --use-local --tag=$TAG"

    EXTRA_PARAMS=""
    if [ -n "$LIBRARIES" -a "$LIBRARIES" != "all" ]; then
        EXTRA_PARAMS="$EXTRA_PARAMS --libraries=$(spaces_to_commas $LIBRARIES)"
    fi

    local BJAM_OPTIONS="                    \
        -j$NUM_JOBS                         \
        variant=release                     \
        link=static,shared                  \
        runtime-link=shared                 \
        threading=multi                     \
        target-os=android                   \
        testing.launcher=$TESTDIR/adbrunner \
        "

    if [ -n "$STD_CXX" ]; then
        BJAM_OPTIONS="$BJAM_OPTIONS cxxflags='-std=$STD_CXX'"
        RUNNER="${RUNNER}-std-$STD_CXX"
    fi

    BJAM_OPTIONS=$(echo $BJAM_OPTIONS | tr ' ' '\n' | grep -v '^$' | tr '\n' ' ')

    if [ -d $SRCDIR/results ]; then
        # Remove this directory, but keep *.zip
        local TMPRESULTS=$SRCDIR/results.$(uuidgen)

        rm -Rf $TMPRESULTS
        mkdir -p $(dirname $TMPRESULTS)
        run mv $SRCDIR/results $TMPRESULTS
        fail_panic "Cannot move folder"

        run mkdir -p $SRCDIR/results
        fail_panic "Cannot create results $ABI directory"

        for Z in $(ls -1 $TMPRESULTS/*.zip 2>/dev/null); do
            run mv $Z $SRCDIR/results/
            fail_panic "Cannot move file"
        done

        run rm -Rf $TMPRESULTS
    else
        run mkdir -p $SRCDIR/results
        fail_panic "Cannot create results $ABI directory"
    fi

    local ACTIONS="  \
        test-run     \
        test-process \
        collect-logs \
        "
    if [ "$PUBLISH_RESULTS" = "yes" ]; then
        ACTIONS="$ACTIONS upload-logs"
    fi

    local ACTION

    (
        trap "rm -f $SRCDIR/user-config.jam" EXIT INT QUIT ABRT TERM
        cp -f $CONFIGJAM $SRCDIR/user-config.jam || exit 1

        export PATH=$TOOLSETS_PATH:$PATH

        cd $SRCDIR || exit 1

        for ACTION in $ACTIONS; do
            log "=== run.py: $ACTION"
            cleanup_pjl "$SRCDIR/boost_regression"

            run $RUNPY                         \
                --runner="$RUNNER"             \
                --comment="$COMMENT"           \
                --toolsets=$TOOLSETS           \
                --platform=Android             \
                --timeout=15                   \
                --bjam-options="$BJAM_OPTIONS" \
                $EXTRA_PARAMS                  \
                $ACTION                        \
                || exit 1
        done
    )
    fail_panic "$ABI tests failed"

    return 0
}

generate_runner_comment()
{
    local COMMENT="$1"
    local ABI="$2"
    local DEVICES="$3"
    local CONFIGJAM="$4"
    local COMPILERS="$5"

    local APILEVEL

    run mkdir -p $(dirname $COMMENT)
    fail_panic "Cannot create directory"

    if [ $(cat $DEVICES 2>/dev/null | wc -l) -gt 1 ]; then
        ANAME="several Android emulators (or having several Android devices connected)"
    else
        ANAME="Android emulator (or having Android device connected)"
    fi

    {
        cat <<HTML
<h2><a href="https://www.crystax.net/" target="_blank">CrystaX.NET</a></h2>

<p>
This runner is a $(uname -s) machine, running ${ANAME}.<br/>
</p>
HTML
        if [ -n "$STD_CXX" ]; then
            echo "<p>All tests were built with -std=$STD_CXX option.</p>"
        fi

        echo "<p>ABI: $ABI</p>"

        echo '<p>'
        echo 'Test devices:<br/>'
        echo '<table style="border-collapse: collapse;">'
        echo '<tr>'
        for V in "Android version" "API level" "Device"; do
            printf '<th style="border: solid 1px #ccc; padding: 0.5em;">%s</th>\n' "$V"
        done
        echo '</tr>'
        cat $DEVICES 2>/dev/null | sort
        echo '</table>'
        echo '</p>'

        cat <<HTML
<p>
<a href="https://www.crystax.net/android/ndk" target="_blank">CrystaX NDK</a> was used to run these tests.
</p>

<p>
user-config.jam
<pre>
$(cat $CONFIGJAM 2>/dev/null)
</pre>
</p>
HTML

        local CXX
        echo "<pre>"
        for CXX in $COMPILERS; do
            echo "\$ $CXX --version"
            $CXX --version 2>&1 | grep -v '^$'
            echo ""
        done
        echo "</pre>"

        cat <<HTML
<p>
<a href="https://www.crystax.net/service" target="_blank">Our services</a><br/>
<a href="https://www.crystax.net/contact" target="_blank">Contact us</a><br/>
</p>
HTML
    } | cat >$COMMENT
    fail_panic "Cannot generate runner's comment.html"
}

fetch()
{
    local URL="$1"
    local DIR="$2"
    local BRANCH="$3"

    if [ -z "$BRANCH" ]; then
        BRANCH=master
    fi

    log "=== Fetching $URL to $DIR (branch $BRANCH)"

    local PARENT=$(dirname $DIR)
    local LOCKFILE="${DIR}.lock"

    (
    run mkdir -p $PARENT || exit 1
    exec 3>$LOCKFILE
    run $FLOCK 3 || exit 1

    if [ ! -d $DIR ]; then
        run mkdir -p $DIR || exit 1
        run cd $DIR || exit 1
        run git init || exit 1
    else
        run cd $DIR || exit 1
    fi
    run git config remote.origin.url "$URL" || exit 1
    run git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*' || exit 1
    run git fetch --prune origin || exit 1
    run git reset --hard || exit 1
    run git clean -ffddx || exit 1
    run git submodule foreach --recursive 'git reset --hard && git clean -ffddx' || exit 1

    SHA1=$(git rev-list --max-count=1 origin/$BRANCH)
    test -n "$SHA1" || exit 1

    run git checkout -q $SHA1 || exit 1
    run git branch -D $BRANCH 2>/dev/null

    run git checkout -b $BRANCH || exit 1
    run git submodule sync --recursive || exit 1
    run git submodule update --recursive --init || exit 1
    )
    fail_panic "Cannot fetch $URL to $DIR"
}

fetch_boost()
{
    local DIR="$1"

    dump "Fetching Boost sources"

    fetch "$BOOST_GIT_URL" "$DIR" "$TAG"
}

fetch_boost_bb()
{
    local DIR="$1"

    dump "Fetching Boost build sources"

    fetch "$BOOST_BUILD_GIT_URL" "$DIR" "develop"
}

fetch_boost_rr()
{
    local DIR="$1"

    dump "Fetching Boost regression sources"

    fetch "$BOOST_REGRESSION_GIT_URL" "$DIR" "develop"
}

FLOCK=$TEST_DIR/flock.$(uuidgen)
rm -f $FLOCK
at_exit "rm -f $FLOCK"
generate_flock $FLOCK

BOOST_SRCDIR=$TEST_DIR/$TAG/src/boost
BOOST_BB_SRCDIR=$TEST_DIR/$TAG/src/boost_bb
BOOST_RR_SRCDIR=$TEST_DIR/$TAG/src/boost_rr

if [ "$DO_FETCH" = "yes" ]; then
    fetch_boost $BOOST_SRCDIR
    fetch_boost_bb $BOOST_BB_SRCDIR
    fetch_boost_rr $BOOST_RR_SRCDIR
else
    if [ ! -d $BOOST_SRCDIR ]; then
        panic "Boost sources are not fetched. Cannot continue; Aborting."
    fi
    if [ ! -d $BOOST_BB_SRCDIR ]; then
        panic "Boost build sources are not fetched. Cannot continue; Aborting."
    fi
    if [ ! -d $BOOST_RR_SRCDIR ]; then
        panic "Boost regression sources are not fetched. Cannot continue; Aborting."
    fi
fi

if [ "$DO_REGRESSION_TESTING" = "yes" ]; then
    for ABI in $ABIS; do
        NUM_DEVICES=$(adb_devices $ABI | wc -l)
        if [ $NUM_DEVICES -eq 0 ]; then
            dump "Skip regression tests [$ABI]: no compatible devices found"
            continue
        fi

        log "Found $NUM_DEVICES $ABI-compatible devices"

        test_boost_for_abi "$ABI" "$REGRESSION_DIR/$ABI"
    done
fi

dump "Done!"
