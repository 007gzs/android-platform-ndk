#!/bin/bash

# Copyright (c) 2011-2014 CrystaX .NET.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY CrystaX .NET ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CrystaX .NET OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of CrystaX .NET.

PROGDIR=`dirname $0`
PROGDIR=`cd $PROGDIR && pwd`

# Assume that we are under tests/
# and that the samples will be under samples/ and platforms/android-N/samples/
#
ROOTDIR=`cd $PROGDIR/.. && pwd`
NDK_BUILDTOOLS_PATH=$ROOTDIR/build/tools
. $NDK_BUILDTOOLS_PATH/ndk-common.sh
. $NDK_BUILDTOOLS_PATH/prebuilt-common.sh

PROGRAM_PARAMETERS=""

PROGRAM_DESCRIPTION=\
"Test Boost libraries built for the CrystaX NDK.

This requires a temporary NDK installation containing
toolchain binaries for all target architectures.

By default, this will try with the current NDK directory, unless
you use the --ndk-dir=<path> option.
"

NDK_DIR=$ANDROID_NDK_ROOT
register_var_option "--ndk-dir=<path>" NDK_DIR "Specify NDK root path for the build"

TEST_DIR=$HOME/.crystax/boost
OPTION_TEST_DIR=
register_var_option "--test-dir=<path>" OPTION_TEST_DIR "Specify test directory [$TEST_DIR]"

ABIS="$PREBUILT_ABIS"
register_var_option "--abis=<list>" ABIS "Specify list of target ABIs"

ADB=adb
register_var_option "--adb=<path>" ADB "Specify which adb to use"

DEVICES_FROM=
register_var_option "--devices-from=<file>" DEVICES_FROM "If specified, use device identificators from that file instead of auto-detecting them with 'adb devices'"

LIBRARIES=all
register_var_option "--libraries=<list>" LIBRARIES "Explicit list of libraries to test"

DEVICE_PATH=/data/local/tmp/boost-$(uuidgen)
register_var_option "--device-path=<path>" DEVICE_PATH "Path on device where to push files"

REPORTS_PATH=$TEST_DIR/reports
register_var_option "--reports=<path>" REPORTS_PATH "Path to store HTML reports"

ENABLE_PIE=yes
register_option "--pie" do_pie "Produce PIE-enabled binaries to test (default)"
do_pie () { ENABLE_PIE=yes; }
register_option "--no-pie" do_no_pie "Produce PIE-disabled binaries to test"
do_no_pie () { ENABLE_PIE=no; }

DO_FETCH=yes
register_option "--skip-fetch-sources" do_skip_fetch_sources "Fetch&update Boost sources"
do_skip_fetch_sources () { DO_FETCH=no; }

PUBLISH_RESULTS=no
register_option "--publish-results" do_publish_results "Publish test results, uploading them to the public FTP"
do_publish_results () { PUBLISH_RESULTS=yes; }

TOOLCHAIN_VERSIONS=gcc-4.9,gcc-4.8,clang-3.5,clang-3.4
register_var_option "--toolchain-versions=<ver>" TOOLCHAIN_VERSIONS "Toolchain versions"

TAG="master"
register_var_option "--tag=<value>" TAG "Boost tag to test ('master' or 'develop')"

BOOST_GIT_URL=https://github.com/boostorg/boost
register_var_option "--boost-url=<url>" BOOST_GIT_URL "Use alternative git URL for Boost sources"

BOOST_BUILD_GIT_URL=https://github.com/boostorg/build.git
register_var_option "--boost-build-url=<url>" BOOST_BUILD_GIT_URL "Use alternative git URL for Boost.Build sources"

BOOST_REGRESSION_GIT_URL=https://github.com/boostorg/regression.git
register_var_option "--boost-regression-url=<url>" BOOST_REGRESSION_GIT_URL "Use alternative git URL for Boost.Regression sources"

STD_CXX=
register_var_option "--std=<standard>" STD_CXX "Use specified C++ standard to build tests"

OPTION_RUNNER=
register_var_option "--runner=<runner>" OPTION_RUNNER "Explicit runner name"

RUNNER_COMMENT_HEADER=
register_var_option "--runner-comment-header=<file>" RUNNER_COMMENT_HEADER "Header of runner comment"

RUNNER_COMMENT_FOOTER=
register_var_option "--runner-comment-footer=<file>" RUNNER_COMMENT_FOOTER "Footer of runner comment"

ICU_VERSION=
register_var_option "--with-icu=<version>" ICU_VERSION "Test with ICU"

register_jobs_option

extract_parameters "$@"

LIBCRYSTAX=$NDK_DIR/$CRYSTAX_SUBDIR

#ICU_VERSION=$(ls -1 $NDK_DIR/$ICU_SUBDIR/ 2>/dev/null | head -n 1)
if [ -n "$ICU_VERSION" ]; then
    ICU=$NDK_DIR/$ICU_SUBDIR/$ICU_VERSION
    if [ ! -d $ICU ]; then
        echo "ERROR: No ICU $ICU_VERSION found in $NDK_DIR" 1>&2
        exit 1
    fi
else
    ICU=""
fi

ABIS=$(commas_to_spaces $ABIS)
TOOLCHAIN_VERSIONS=$(commas_to_spaces $TOOLCHAIN_VERSIONS)

case $TAG in
    master|develop)
        ;;
    *)
        panic "Wrong tag value: '$TAG'"
esac

if [ -n "$OPTION_TEST_DIR" ]; then
    eval TEST_DIR=$OPTION_TEST_DIR
fi
mkdir -p "$TEST_DIR"
fail_panic "Cannot create test directory: $TEST_DIR"

REGRESSION_DIR="$TEST_DIR/$TAG/regression"
REPORT_DIR="$TEST_DIR/$TAG/report"

setup_default_log_file $TEST_DIR/test.log

mkdir -p $REPORTS_PATH
fail_panic "Cannot create results directory: $REPORTS_PATH"

STDBUF=
which stdbuf >/dev/null 2>&1 && STDBUF="stdbuf -o0"

f_at_exit=/tmp/atexit.$(uuidgen)
rm -f $f_at_exit

at_exit()
{
    echo "$@" >>$f_at_exit
}

cleanup()
{
    local pid
    cat $f_at_exit 2>/dev/null | {
        while read cmd; do
            echo "## CLEANUP: $cmd"
            $cmd
        done
    }
}

trap "cleanup" EXIT QUIT ABRT TERM
trap "printf '\\n\\n*** INTERRUPTED: $0\\n\\n'; exit 1" INT

WLOG=/tmp/wrappers-$(uuidgen).log
rm -f $WLOG
touch $WLOG >/dev/null 2>&1
tail -F $WLOG | catlog &
WPID=$(jobs -p)

kill_wlog()
{
    kill -INT  $WPID 2>/dev/null
    sleep 0.5
    kill -KILL $WPID 2>/dev/null
}

at_exit kill_wlog

cleanup_devices()
{
    adb_devices | {
        while read D; do
            $ADB -s "$D" shell "rm -r $DEVICE_PATH 2>/dev/null"
        done
    }
}

at_exit cleanup_devices

mktool()
{
    local tool="$1"
    mkdir -p $(dirname $tool)
    fail_panic "Cannot create parent directory for tool $tool"
    cat >$tool
    fail_panic "Cannot create tool $tool"
    chmod +x $tool
    fail_panic "Cannot chmod +x $tool"
}

adb_getprop()
{
    local DEVID="$1"
    local PROPNAME="$2"
    $ADB -s "$DEVID" shell getprop $PROPNAME | tr -d '\r'
}

adb_devices()
{
    local ABI=$1
    local D C CPU_ABI CPU_ABI2 CPU_ABIS
    local APILEVEL

    if [ -n "$DEVICES_FROM" ]; then
        cat $DEVICES_FROM 2>/dev/null
        return
    fi

    $ADB devices | tr -d '\r' | sed -e '1d' | grep '\<device$' | sed -e 's/^\([^\t]*\).*$/\1/' | {
    while read D; do
        if [ -z "$ABI" ]; then
            echo "$D"
            continue
        fi

        APILEVEL=$(adb_getprop "$D" ro.build.version.sdk)
        if [ "$ENABLE_PIE" = "yes" ]; then
            if [ $APILEVEL -le 15 ]; then
                #echo "SKIP test on $D: android-$APILEVEL don't support PIE-enabled binaries"
                continue
            fi
        else
            if [ $APILEVEL -ge 21 ]; then
                #echo "SKIP test on $D: android-$APILEVEL don't support non-PIE binaries"
                continue
            fi
        fi

        CPU_ABIS=$(adb_getprop "$D" ro.product.cpu.abilist)
        if [ -z "$CPU_ABIS" ]; then
            CPU_ABI=$(adb_getprop "$D" ro.product.cpu.abi)
            CPU_ABI2=$(adb_getprop "$D" ro.product.cpu.abi2)
            CPU_ABIS="$CPU_ABI,$CPU_ABI2"
        fi
        CPU_ABIS=$(echo $CPU_ABIS | tr ',' ' ')
        if echo $CPU_ABIS | tr ' ' '\n' | grep -q -x armeabi-v7a; then
            CPU_ABIS="$CPU_ABIS armeabi-v7a-hard"
        fi
        DEVICE_ABI=$(echo $CPU_ABIS | tr ' ' '\n' | head -n 1)
        for C in $CPU_ABIS; do
            if [ "$C" != "$ABI" ]; then
                continue
            fi

            # Special case: Dell Venue x86 tablet specify 'ro.product.cpu.abi=x86' and 'ro.product.cpu.abi2=armeabi-v7a'.
            # However, only non-PIE-enabled armeabi-v7a binaries supported, even though for x86 binaries usual
            # rules applied - i.e. PIE binaries works starting from android-16 and non-PIE binaries works only up to android-19.
            case $C in
                armeabi-v7a*)
                    if [ "$DEVICE_ABI" = "x86" -a "$ENABLE_PIE" = "yes" ]; then
                        continue
                    fi
                    ;;
            esac

            echo "$D"
        done
    done
    }
}

# $1: ABI
# $2: toolchain type (gcc or clang)
# $3: toolchain version
# $4: target directory
generate_toolchain()
{
    local ABI=$1
    local TOOLCHAIN_TYPE=$2
    local TOOLCHAIN_VERSION=$3
    local DIR=$4

    local APILEVEL=9
    if [ ${ABI%%64*} != ${ABI} ]; then
        APILEVEL=21
    fi

    local TCNAME
    case $ABI in
        armeabi*)
            TCNAME=arm-linux-androideabi
            ;;
        arm64*)
            TCNAME=aarch64-linux-android
            ;;
        mips)
            TCNAME=mipsel-linux-android
            ;;
        mips64)
            TCNAME=mips64el-linux-android
            ;;
        x86|x86_64)
            TCNAME=$ABI
            ;;
        *)
            echo "ERROR: Unknown ABI: $ABI" 1>&2
            exit 1
    esac

    local TCPREFIX
    case $ABI in
        x86)
            TCPREFIX=i686-linux-android
            ;;
        x86_64)
            TCPREFIX=x86_64-linux-android
            ;;
        *)
            TCPREFIX=$TCNAME
    esac

    local LLVMTRIPPLE
    case $ABI in
        armeabi)
            LLVMTRIPPLE=armv5te-none-linux-androideabi
            ;;
        armeabi-v7a*)
            LLVMTRIPPLE=armv7-none-linux-androideabi
            ;;
        arm64-v8a)
            LLVMTRIPPLE=aarch64-none-linux-android
            ;;
        x86)
            LLVMTRIPPLE=i686-none-linux-android
            ;;
        x86_64)
            LLVMTRIPPLE=x86_64-none-linux-android
            ;;
        mips)
            LLVMTRIPPLE=mipsel-none-linux-android
            ;;
        mips64)
            LLVMTRIPPLE=mips64el-none-linux-android
            ;;
        *)
            echo "ERROR: Unknown ABI: $ABI" 1>&2
            exit 1
    esac

    local ARCH
    case $ABI in
        armeabi*)
            ARCH=arm
            ;;
        arm64*)
            ARCH=arm64
            ;;
        *)
            ARCH=$ABI
    esac

    local FLAGS LFLAGS LLIBS
    case $ABI in
        armeabi)
            FLAGS="-march=armv5te -mtune=xscale -msoft-float"
            ;;
        armeabi-v7a)
            FLAGS="-march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=softfp"
            LFLAGS="-Wl,--fix-cortex-a8"
            ;;
        armeabi-v7a-hard)
            FLAGS="-march=armv7-a -mfpu=vfpv3-d16 -mhard-float"
            LFLAGS="-Wl,--fix-cortex-a8"
            LFLAGS="$LFLAGS -Wl,--no-warn-mismatch"
            ;;
        arm64-v8a)
            FLAGS=""
            ;;
        x86)
            FLAGS="-m32"
            ;;
        x86_64)
            FLAGS="-m64"
            ;;
        mips)
            FLAGS="-mabi=32 -mips32"
            ;;
        mips64)
            FLAGS="-mabi=64 -mips64r6"
            ;;
    esac

    local GCCTCPATH
    local CCS
    case $TOOLCHAIN_TYPE in
        gcc)
            GCCTCPATH=$NDK_DIR/toolchains/$TCNAME-$TOOLCHAIN_VERSION/prebuilt/$HOST_TAG
            CCS="gcc g++"
            GNULIBCXX_VERSION=$TOOLCHAIN_VERSION
            ;;
        clang)
            LLVMGCCVERSION=4.9
            GCCTCPATH=$NDK_DIR/toolchains/$TCNAME-$LLVMGCCVERSION/prebuilt/$HOST_TAG
            LLVMTCPATH=$NDK_DIR/toolchains/llvm-$TOOLCHAIN_VERSION/prebuilt/$HOST_TAG
            CCS="clang clang++"
            GNULIBCXX_VERSION=$LLVMGCCVERSION
            ;;
        *)
            echo "ERROR: Unknown toolchain type: $TOOLCHAIN_TYPE" 1>&2
            exit 1
    esac

    local SYSROOT=$NDK_DIR/platforms/android-$APILEVEL/arch-$ARCH
    local GNULIBCXX=$NDK_DIR/sources/cxx-stl/gnu-libstdc++/$GNULIBCXX_VERSION

    FLAGS="$FLAGS --sysroot=$SYSROOT"

    FLAGS="$FLAGS -fPIC"
    if [ "$ENABLE_PIE" = "yes" ]; then
        FLAGS="$FLAGS -fPIE"
        LFLAGS="$LFLAGS -pie"
    fi

    LLIBS="-lgnustl_shared"

    local TOOL
    for TOOL in $CCS; do
        {
            cat <<EOF
#!/bin/bash

if echo "\$@" | tr ' ' '\\n' | grep -q -x -e -c; then
    LINKER=no
else
    LINKER=yes
fi

# Remove any -m32/-m64 from input parameters
PARAMS=\`echo "\$@" | tr ' ' '\\n' | grep -v -x -e -m32 | grep -v -x -e -m64 | tr '\\n' ' '\`
if [ "x\$LINKER" = "xyes" ]; then
    NPARAMS=""
    for p in \$PARAMS; do
        case \$p in
            -lrt|-pthread|-lpthread)
                continue
                ;;
        esac

        NPARAMS="\$NPARAMS \$p"
    done
    PARAMS=\$NPARAMS
fi

FLAGS="$FLAGS"
if [ "x\$LINKER" = "xyes" ]; then
    FLAGS="\$FLAGS $LFLAGS"
    if [ "x$ICU" != "x" ]; then
        FLAGS="\$FLAGS -L$ICU/libs/$ABI"
    fi
    FLAGS="\$FLAGS -L$LIBCRYSTAX/libs/$ABI"
    FLAGS="\$FLAGS -L$GNULIBCXX/libs/$ABI"
else
    if [ "x$ICU" != "x" ]; then
        FLAGS="\$FLAGS -I$ICU/include"
    fi
    FLAGS="\$FLAGS -I$GNULIBCXX/include"
    FLAGS="\$FLAGS -I$GNULIBCXX/libs/$ABI/include"
    FLAGS="\$FLAGS -I$LIBCRYSTAX/include"
    FLAGS="\$FLAGS -Wno-long-long"
fi

PARAMS="\$FLAGS \$PARAMS"
if [ "x\$LINKER" = "xyes" ]; then
    PARAMS="\$PARAMS $LLIBS"
fi

run()
{
    echo "## COMMAND: \$@" >>$WLOG
    exec "\$@"
}
EOF

            case $TOOLCHAIN_TYPE in
                gcc)
                    echo "run $GCCTCPATH/bin/$TCPREFIX-$TOOL \$PARAMS"
                    ;;
                clang)
                    echo "run $LLVMTCPATH/bin/$TOOL \\"
                    echo "    -target $LLVMTRIPPLE \\"
                    echo "    -gcc-toolchain $GCCTCPATH \\"
                    echo "    \$PARAMS"
                    ;;
                *)
                    echo "echo 'WRONG TOOLCHAIN TYPE: $TOOLCHAIN_TYPE' 1>&2"
                    echo "exit 1"
            esac
        } | mktool $DIR/$TOOL-$TOOLCHAIN_VERSION
        fail_panic "Cannot create target tool $TOOL"
    done

    for TOOL in as ar; do
        {
            echo "#!/bin/bash"
            echo 'run()'
            echo '{'
            echo '    echo "## COMMAND: $@" >>'$WLOG
            echo '    exec "$@"'
            echo '}'
            case $TOOLCHAIN_TYPE in
                gcc)
                    echo "run $GCCTCPATH/bin/$TCPREFIX-$TOOL \"\$@\""
                    ;;
                clang)
                    echo "run $LLVMTCPATH/bin/llvm-$TOOL \"\$@\""
                    ;;
                *)
                    echo "echo 'WRONG TOOLCHAIN TYPE: $TOOLCHAIN_TYPE' 1>&2"
                    echo "exit 1"
            esac
        } | mktool $DIR/$TOOL
        fail_panic "Cannot create target tool $TOOL"
    done

    for TOOL in ranlib strip; do
        {
            echo "#!/bin/bash"
            echo 'run()'
            echo '{'
            echo '    echo "## COMMAND: $@" >>'$WLOG
            echo '    exec "$@"'
            echo '}'
            echo "run $GCCTCPATH/bin/$TCPREFIX-$TOOL \"\$@\""
        } | mktool $DIR/$TOOL
        fail_panic "Cannot create target tool $TOOL"
    done
}

# $1: ABI
# $2: target directory
# $3: 'strip' utility
generate_adbrunner()
{
    local ABI="$1"
    local DIR="$2"
    local STRIP="$3"

    local LIBDIR="$DIR/lib"
    run rm -Rf $LIBDIR

    local ADBRUNNER=$DIR/adbrunner
    {
        echo '#!/bin/bash'
        echo ''
        echo 'echo "## COMMAND: $0 $@" >>'$WLOG
        echo ''

        local PARAMS=""
        PARAMS="$PARAMS --log=$WLOG"
        PARAMS="$PARAMS --abi=$ABI"
        PARAMS="$PARAMS --adb=$ADB"
        PARAMS="$PARAMS --strip=$STRIP"
        PARAMS="$PARAMS --lib-directory=$LIBDIR"
        if [ "$ENABLE_PIE" = "yes" ]; then
            PARAMS="$PARAMS --pie"
        else
            PARAMS="$PARAMS --no-pie"
        fi
        if [ -n "$DEVICES_FROM" ]; then
            PARAMS="$PARAMS --devices-from=$DEVICES_FROM"
        fi

        echo 'exec '$NDK_DIR'/tools/adbrunner '$PARAMS' "$@"'
    } | mktool $ADBRUNNER
}

# $1: target directory
copy_boost()
{
    local DIR="$1"

    # WARNING! This is intentionally just 'rm', not 'rm -rf'.
    # This is needed to remove $DIR if it's symlink.
    # Thus, we try to remove it and ignore any errors.
    # In case it's symlink - it will be removed.
    # In case it's directory - nothing will happen.
    rm $DIR >/dev/null 2>&1

    run mkdir -p $DIR
    fail_panic "Cannot create target directory for Boost sources"

    run rsync -a "$BOOST_SRCDIR/" "$DIR/"
    fail_panic "Cannot copy Boost sources"
}

copy_boost_bb()
{
    local DIR="$1"

    run mkdir -p $DIR
    fail_panic "Cannot create target directory for Boost.Build sources"

    run rsync -a "$BOOST_BB_SRCDIR/" "$DIR/"
    fail_panic "Cannot copy Boost.Build sources"
}

copy_boost_rr()
{
    local DIR="$1"

    run mkdir -p $DIR
    fail_panic "Cannot create target directory for Boost.Regression sources"

    run rsync -a "$BOOST_RR_SRCDIR/" "$DIR/"
    fail_panic "Cannot copy Boost.Regression sources"
}

PJL=/tmp/process_jam_log.$(uuidgen)
at_exit "rm -f $PJL"
HOST_PJL=

cleanup_pjl()
{
    local DIR="$1"

    find $DIR/build/bin -type f -a -name process_jam_log -delete

    if [ -n "$HOST_PJL" ]; then
        run mkdir -p $(dirname $DIR/build/bin/$HOST_PJL)
        fail_panic "Cannot create directory for host process_jam_log"

        run cp -f $PJL $DIR/build/bin/$HOST_PJL
        fail_panic "Cannot copy host process_jam_log from backup"
    fi
}

prepare_boost_tools()
{
    local DIR="$1"

    mkdir -p $DIR
    fail_panic "Cannot create boost sources directory"

    local RUNPY=$DIR/run.py

    run cp -f $BOOST_RR_SRCDIR/src/run.py $RUNPY
    fail_panic "Cannot retrieve run.py"

    chmod +x $RUNPY
    fail_panic "Cannot chmod +x run.py"

    local BOOST_BB="$DIR/boost_bb"
    copy_boost_bb "$BOOST_BB"

    local BOOST_RR="$DIR/boost_regression"
    copy_boost_rr "$BOOST_RR"

    local TOOLS="                  \
        collect_and_upload_logs.py \
        process_jam_log.py         \
        regression.py              \
        "

    local T
    for T in $TOOLS; do
        run cp -f "$BOOST_RR/src/$T" "$DIR/"
        fail_panic "Cannot copy $T to $DIR"
    done

    HOST_PJL=""
    cleanup_pjl

    (
    cd $DIR || exit 1
    run $RUNPY --use-local --tag=$TAG --bjam-options="-j$NUM_JOBS" setup || exit 1
    )
    fail_panic "Cannot setup regression tools"

    HOST_PJL=$(find $BOOST_RR/build/bin -type f -a -name process_jam_log -print | head -n 1 | sed "s,^$BOOST_RR/build/bin/,,")
    if [ -z "$HOST_PJL" ]; then
        panic "Cannot find just built process_jam_log"
    fi
    log "HOST_PJL: $HOST_PJL"
    cp -f $BOOST_RR/build/bin/$HOST_PJL $PJL
    fail_panic "Cannot backup host process_jam_log"
}

# $1: ABI
runner_name()
{
    local ABI="$1"

    local FLEVELS=/tmp/apilevels.$(uuidgen)
    rm -f $FLEVELS
    at_exit "rm -f $FLEVELS"
    adb_devices $ABI | {
        local D
        while read D; do
            adb_getprop "$D" ro.build.version.sdk >>$FLEVELS
        done
    }
    cat $FLEVELS | sed 's,^,RUNNER: FLEVELS: ,' | catlog
    local APILEVELS=$(cat $FLEVELS | sort | uniq | tr '\n' ' ')
    rm -f $FLEVELS
    if [ -z "$APILEVELS" ]; then
        panic "Cannot detect API levels"
    fi

    APILEVELS=$(echo $APILEVELS | tr -s ' ' | tr ' ' ',')

    local RUNNER="Android-apilevel-$APILEVELS-$ABI"
    log "RUNNER: $RUNNER"
    echo $RUNNER
}

# $1: ABI
# $2: test directory
test_boost_for_abi ()
{
    local ABI="$1"
    local TESTDIR="$2"
    local SRCDIR="$TESTDIR/test"

    dump "Run regression testing [$ABI]"

    run mkdir -p $TESTDIR && run mkdir -p $SRCDIR
    fail_panic "Cannot create temporary directory for $ABI testing"

    local STRIP=""
    local TOOLSETS=""
    local TOOLSETS_PATH=""
    local TOOLSET
    local TOOLCHAIN_TYPE TOOLCHAIN_VERSION
    local CXXBIN
    local CXXBINS=""

    local CONFIGJAM="$TESTDIR/config.jam"
    run rm -f $CONFIGJAM

    for TOOLCHAIN_VERSION in $TOOLCHAIN_VERSIONS; do
        if [ ${TOOLCHAIN_VERSION#clang} != ${TOOLCHAIN_VERSION} ]; then
            TOOLCHAIN_TYPE=clang
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#clang-}
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#clang}
            CXXBIN=clang++-$TOOLCHAIN_VERSION
        else
            TOOLCHAIN_TYPE=gcc
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#gcc-}
            TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION#gcc}
            CXXBIN=g++-$TOOLCHAIN_VERSION
        fi

        if [ "$TOOLCHAIN_TYPE" = "clang" -a "$ABI" = "armeabi" ]; then
            # clang toolchains don't support armeabi good
            continue
        fi

        if [ "$TOOLCHAIN_TYPE" = "gcc" -a "$TOOLCHAIN_VERSION" = "4.8" -a ${ABI%%64*} != ${ABI} ]; then
            # gcc-4.8 don't support 64-bit targets
            continue
        fi

        TOOLSET=${TOOLCHAIN_TYPE}-${TOOLCHAIN_VERSION}

        local TARGETBIN=$TESTDIR/${TOOLSET}
        run rm -Rf $TARGETBIN

        # Generate toolchain wrappers
        generate_toolchain "$ABI" "$TOOLCHAIN_TYPE" "$TOOLCHAIN_VERSION" "$TARGETBIN"

        if [ -z "$TOOLSETS" ]; then
            TOOLSETS=$TOOLSET
        else
            TOOLSETS="$TOOLSETS,$TOOLSET"
        fi

        if [ -z "$TOOLSETS_PATH" ]; then
            TOOLSETS_PATH=$TARGETBIN
        else
            TOOLSETS_PATH=$TOOLSETS_PATH:$TARGETBIN
        fi

        echo "using $TOOLCHAIN_TYPE : $TOOLCHAIN_VERSION : $TARGETBIN/$CXXBIN ;" >>$CONFIGJAM
        fail_panic "Cannot add $TOOLSET to user config"

        CXXBINS="$CXXBINS $TARGETBIN/$CXXBIN"

        if [ -z "$STRIP" -a -x $TARGETBIN/strip ]; then
            STRIP=$TARGETBIN/strip
        fi
    done

    if [ -z "$STRIP" ]; then
        panic "Cannot detect strip for $ABI"
    fi

    # Generate adbrunner tool
    generate_adbrunner "$ABI" "$TESTDIR" "$STRIP"

    # Copy Boost sources
    copy_boost "$SRCDIR/boost_root"

    # Prepare Boost tools (bjam, process_jam_log)
    prepare_boost_tools "$SRCDIR"

    local RUNNER
    if [ -n "$OPTION_RUNNER" ]; then
        RUNNER=$OPTION_RUNNER
    else
        RUNNER=$(runner_name)
        if [ -n "$STD_CXX" ]; then
            RUNNER="${RUNNER}-std-$STD_CXX"
        fi
    fi

    local COMMENT="$SRCDIR/comment.html"
    generate_runner_comment "$COMMENT" "$CONFIGJAM" "$CXXBINS"

    local RUNPY="$SRCDIR/run.py --use-local --tag=$TAG"

    EXTRA_PARAMS=""
    if [ -n "$LIBRARIES" -a "$LIBRARIES" != "all" ]; then
        EXTRA_PARAMS="$EXTRA_PARAMS --libraries=$(spaces_to_commas $LIBRARIES)"
    fi

    local BJAM_OPTIONS="                    \
        -j$NUM_JOBS                         \
        variant=release                     \
        link=static,shared                  \
        runtime-link=shared                 \
        threading=multi                     \
        target-os=android                   \
        testing.launcher=$TESTDIR/adbrunner \
        "

    if [ -n "$STD_CXX" ]; then
        BJAM_OPTIONS="$BJAM_OPTIONS cxxflags='-std=$STD_CXX'"
    fi

    BJAM_OPTIONS=$(echo $BJAM_OPTIONS | tr ' ' '\n' | grep -v '^$' | tr '\n' ' ')

    if [ -d $SRCDIR/results ]; then
        # Remove this directory, but keep *.zip
        local TMPRESULTS=$SRCDIR/results.$(uuidgen)

        rm -Rf $TMPRESULTS
        mkdir -p $(dirname $TMPRESULTS)
        run mv $SRCDIR/results $TMPRESULTS
        fail_panic "Cannot move folder"

        run mkdir -p $SRCDIR/results
        fail_panic "Cannot create results $ABI directory"

        for Z in $(ls -1 $TMPRESULTS/*.zip 2>/dev/null); do
            run mv $Z $SRCDIR/results/
            fail_panic "Cannot move file"
        done

        run rm -Rf $TMPRESULTS
    else
        run mkdir -p $SRCDIR/results
        fail_panic "Cannot create results $ABI directory"
    fi

    local ACTIONS="  \
        test-run     \
        test-process \
        collect-logs \
        "
    if [ "$PUBLISH_RESULTS" = "yes" ]; then
        ACTIONS="$ACTIONS upload-logs"
    fi

    local ACTION

    (
        trap "rm -f $SRCDIR/user-config.jam" EXIT INT QUIT ABRT TERM
        cp -f $CONFIGJAM $SRCDIR/user-config.jam || exit 1

        export PATH=$TOOLSETS_PATH:$PATH

        cd $SRCDIR || exit 1

        for ACTION in $ACTIONS; do
            log "=== run.py: $ACTION"

            cleanup_pjl "$SRCDIR/boost_regression"

            run $RUNPY                         \
                --runner="$RUNNER"             \
                --comment="$COMMENT"           \
                --toolsets=$TOOLSETS           \
                --platform=Android             \
                --timeout=15                   \
                --bjam-options="$BJAM_OPTIONS" \
                $EXTRA_PARAMS                  \
                $ACTION                        \
                || exit 1
        done
    )
    fail_panic "$ABI tests failed"

    return 0
}

generate_runner_comment()
{
    local COMMENT="$1"
    local CONFIGJAM="$2"
    local COMPILERS="$3"

    local APILEVEL

    run mkdir -p $(dirname $COMMENT)
    fail_panic "Cannot create directory"

    {
        if [ -n "$RUNNER_COMMENT_HEADER" ]; then
            cat $RUNNER_COMMENT_HEADER 2>/dev/null
        fi

        cat <<HTML
<p>
user-config.jam
<pre>
$(cat $CONFIGJAM 2>/dev/null)
</pre>
</p>
HTML

        local CXX
        echo "<pre>"
        for CXX in $COMPILERS; do
            echo "\$ $CXX --version"
            $CXX --version 2>&1 | grep -v '^$'
            echo ""
        done
        echo "</pre>"

        if [ -n "$RUNNER_COMMENT_FOOTER" ]; then
            cat $RUNNER_COMMENT_FOOTER 2>/dev/null
        fi
    } | cat >$COMMENT
    fail_panic "Cannot generate runner's comment.html"
}

fetch()
{
    local URL="$1"
    local DIR="$2"
    local BRANCH="$3"

    if [ -z "$BRANCH" ]; then
        BRANCH=master
    fi

    log "=== Fetching $URL to $DIR (branch $BRANCH)"

    local PARENT=$(dirname $DIR)

    (
    run mkdir -p $PARENT || exit 1

    if [ ! -d $DIR ]; then
        run mkdir -p $DIR || exit 1
        run cd $DIR || exit 1
        run git init || exit 1
    else
        run cd $DIR || exit 1
    fi
    run git config remote.origin.url "$URL" || exit 1
    run git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*' || exit 1
    run git fetch --prune origin || exit 1
    run git reset --hard || exit 1
    run git clean -ffddx || exit 1
    run git submodule foreach --recursive 'git reset --hard && git clean -ffddx' || exit 1

    SHA1=$(git rev-parse --verify origin/$BRANCH)
    test -n "$SHA1" || exit 1

    run git checkout -q -f $SHA1 || exit 1
    run git branch -D $BRANCH 2>/dev/null

    run git checkout -b $BRANCH || exit 1
    run git submodule init || exit 1
    run git submodule sync --recursive || exit 1
    run git submodule update --recursive || exit 1
    )
    fail_panic "Cannot fetch $URL to $DIR"
}

fetch_boost()
{
    local DIR="$1"

    dump "Fetching Boost sources"

    fetch "$BOOST_GIT_URL" "$DIR" "$TAG"
}

fetch_boost_bb()
{
    local DIR="$1"

    dump "Fetching Boost build sources"

    fetch "$BOOST_BUILD_GIT_URL" "$DIR" "develop"
}

fetch_boost_rr()
{
    local DIR="$1"

    dump "Fetching Boost regression sources"

    fetch "$BOOST_REGRESSION_GIT_URL" "$DIR" "develop"
}

BOOST_SRCDIR=$TEST_DIR/$TAG/src/boost
BOOST_BB_SRCDIR=$TEST_DIR/$TAG/src/boost_bb
BOOST_RR_SRCDIR=$TEST_DIR/$TAG/src/boost_rr

if [ "$DO_FETCH" = "yes" ]; then
    fetch_boost $BOOST_SRCDIR
    fetch_boost_bb $BOOST_BB_SRCDIR
    fetch_boost_rr $BOOST_RR_SRCDIR
else
    if [ ! -d $BOOST_SRCDIR ]; then
        panic "Boost sources are not fetched. Cannot continue; Aborting."
    fi
    if [ ! -d $BOOST_BB_SRCDIR ]; then
        panic "Boost build sources are not fetched. Cannot continue; Aborting."
    fi
    if [ ! -d $BOOST_RR_SRCDIR ]; then
        panic "Boost regression sources are not fetched. Cannot continue; Aborting."
    fi
fi

for ABI in $ABIS; do
    NUM_DEVICES=$(adb_devices $ABI | wc -l)
    if [ $NUM_DEVICES -eq 0 ]; then
        dump "Skip regression tests [$ABI]: no compatible devices found"
        continue
    fi

    log "Found $NUM_DEVICES $ABI-compatible devices"

    test_boost_for_abi "$ABI" "$REGRESSION_DIR/$ABI"
done

dump "Done!"
